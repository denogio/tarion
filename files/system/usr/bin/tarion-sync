#!/usr/bin/env bash
# Tarion configuration synchronization utility
# Ensures ~/.config links to /usr/share/tarion/defaults/ for system defaults
set -euo pipefail

SYNC_HEADER="# -- TARION MANAGED --"
DEFAULTS_DIR="/usr/share/tarion/defaults"
USER_CONFIG_DIR="${HOME}/.config"
STATE_DIR="${HOME}/.cache/tarion"
STATE_FILE="${STATE_DIR}/last-sync"

# Smart Check: Only run if the image has changed
# On atomic systems, /usr is updated as a whole, changing mtime of this dir
IMAGE_ID=$(stat -c %Y "${DEFAULTS_DIR}" 2>/dev/null || echo "0")
LAST_ID=$(cat "${STATE_FILE}" 2>/dev/null || echo "-1")

if [ "${IMAGE_ID}" == "${LAST_ID}" ]; then
    # Image is the same, no need to sync unless explicitly forced
    if [[ "${1:-}" != "--force" ]]; then
        exit 0
    fi
fi

# Bootstrap Check: Ensure brew tools are installed on first use
if [ ! -f "${HOME}/.config/tarion/bootstrap-done" ]; then
    # Run bootstrap in a unified presentation window
    tarion-launch-floating-terminal-with-presentation tarion-bootstrap
fi

sync_app() {
    local app=$1
    local src_file=$2
    local dest_file=$3
    local source_cmd=$4

    mkdir -p "$(dirname "${dest_file}")"

    # If file doesn't exist, create it with sourcing
    if [ ! -f "${dest_file}" ]; then
        echo "Creating default config for ${app}..."
        echo "${SYNC_HEADER}" > "${dest_file}"
        echo "${source_cmd} ${src_file}" >> "${dest_file}"
        return
    fi

    # If it exists, check if it's managed
    if grep -q "${SYNC_HEADER}" "${dest_file}"; then
        # Update sourcing line if needed
        if ! grep -q "${src_file}" "${dest_file}"; then
            echo "Updating ${app} sourcing path..."
            sed -i "s|${source_cmd} .*|${source_cmd} ${src_file}|" "${dest_file}"
        fi
    else
        # Not managed, check if we should add sourcing
        if ! grep -q "${src_file}" "${dest_file}"; then
            echo "Heads up: ${dest_file} is custom but missing tarion defaults."
            # Optionally add it to the top? 
            # We'll be conservative for now and just suggest it or let the user do it.
        fi
    fi
}

# Hyprland - Create user config that sources system defaults + user overrides
HYPR_USER_CONF="${USER_CONFIG_DIR}/hypr/hyprland.conf"
mkdir -p "$(dirname "${HYPR_USER_CONF}")"

if [ ! -f "${HYPR_USER_CONF}" ] || grep -q "${SYNC_HEADER}" "${HYPR_USER_CONF}"; then
    echo "Creating Hyprland user config..."
    cat > "${HYPR_USER_CONF}" <<EOF
${SYNC_HEADER}
# Tarion Hyprland Configuration
# This file sources system defaults and then applies user-specific overrides

# 1. Source system defaults (keybindings, look & feel, etc.)
source = ${DEFAULTS_DIR}/hyprland.conf

# 2. Source user-specific input config (keyboard layout, etc.)
source = ?~/.config/hypr/input.conf

# 3. Source current theme
source = ?~/.config/tarion/current/theme/hyprland.conf

# 4. Add your custom overrides below this line
# Example:
# bind = SUPER, T, exec, custom-script
EOF
fi

# Ghostty
sync_app "Ghostty" "${DEFAULTS_DIR}/ghostty/config" "${USER_CONFIG_DIR}/ghostty/config" "config-file ="

# Hyprland Input - Dynamic keyboard layout based on locale
HYPR_INPUT_DEST="${USER_CONFIG_DIR}/hypr/input.conf"
mkdir -p "$(dirname "${HYPR_INPUT_DEST}")"

# Detect keyboard layout from system locale
LOCALE_LANG="${LANG%%.*}"  # e.g., "da_DK" -> "da_DK"
KB_LAYOUT="us"  # Default fallback

case "${LOCALE_LANG}" in
    da_*|dk_*|*_dk) KB_LAYOUT="dk" ;;
    de_*) KB_LAYOUT="de" ;;
    fr_*) KB_LAYOUT="fr" ;;
    es_*) KB_LAYOUT="es" ;;
    it_*) KB_LAYOUT="it" ;;
    sv_*) KB_LAYOUT="se" ;;
    no_*|nb_*|nn_*) KB_LAYOUT="no" ;;
    fi_*) KB_LAYOUT="fi" ;;
    *) KB_LAYOUT="us" ;;
esac

# Create user input.conf with detected layout
cat > "${HYPR_INPUT_DEST}" <<EOF
# Auto-generated by tarion-sync
# Source system defaults
source = ${DEFAULTS_DIR}/hypr/input.conf

# Override keyboard layout based on system locale (${LOCALE_LANG})
input {
    kb_layout = ${KB_LAYOUT}
}
EOF

echo "Set keyboard layout to: ${KB_LAYOUT} (from locale: ${LOCALE_LANG})"

# Vicinae settings sync
VICINAE_DEST="${USER_CONFIG_DIR}/vicinae/settings.json"
VICINAE_SRC="${DEFAULTS_DIR}/vicinae/settings.json"

# Check if user has custom config or just default import
if [ ! -f "${VICINAE_DEST}" ]; then
    echo "Creating default Vicinae settings..."
    mkdir -p "$(dirname "${VICINAE_DEST}")"
    cp "${VICINAE_SRC}" "${VICINAE_DEST}"
elif grep -q "\"imports\".*\"${DEFAULTS_DIR}/vicinae/settings.json\"" "${VICINAE_DEST}" 2>/dev/null; then
    # User only has the import statement (default config), overwrite with latest defaults
    echo "Updating Vicinae settings to latest defaults..."
    cp "${VICINAE_SRC}" "${VICINAE_DEST}"
fi

# Default Theme Link
# Ensures that ~/.config/tarion/current/theme points to a valid theme (default: catppuccin-mocha)
# so that Hyprland can source it.
THEME_LINK="${HOME}/.config/tarion/current/theme"
TARGET_THEME="/usr/share/tarion/themes/catppuccin-mocha"

if [ ! -e "${THEME_LINK}" ]; then
    echo "Setting default theme to Catppuccin Mocha..."
    mkdir -p "$(dirname "${THEME_LINK}")"
    ln -sf "${TARGET_THEME}" "${THEME_LINK}"
fi

# Keybindings cache
# Generate cache for keybinding viewer
echo "Generating keybindings cache..."
if command -v tarion-keybindings-generate &>/dev/null; then
    tarion-keybindings-generate > /dev/null
fi

# Update state
mkdir -p "${STATE_DIR}"
echo "${IMAGE_ID}" > "${STATE_FILE}"

echo "âœ“ Tarion configuration sync complete!"
